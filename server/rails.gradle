/*
 * Copyright Thoughtworks, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import com.thoughtworks.go.build.*
import groovy.text.SimpleTemplateEngine
import groovy.text.Template
import org.apache.tools.ant.types.Commandline
import org.gradle.internal.jvm.Jvm

def bundlePath = project.file("${project.railsRoot}/gems")
def jrubyScriptsDir = project.file("scripts")
project.ext.jrubyScriptsDir = jrubyScriptsDir

def createJRubyBinstubs = tasks.register('createJRubyBinstubs') {
  group = LifecycleBasePlugin.BUILD_GROUP
  dependsOn configurations.jruby

  def ext = org.gradle.internal.os.OperatingSystem.current().isWindows() ? '.bat' : ''
  def outputScriptFile = file("${jrubyScriptsDir}/jruby${ext}")
  def templateProperties = [
    mainClassName       : 'org.jruby.Main',
    jvmArgs             : JRuby.jrubyJvmArgs,
    systemProperties    : JRuby.jrubySystemProperties,
    additionalJRubyPaths: [jrubyScriptsDir],
    javaExecutable      : Jvm.current().getExecutable("java")
  ] as Map<String, ?>

  inputs.dir("script-templates")
  inputs.properties(templateProperties)
  outputs.files(outputScriptFile)
  outputs.cacheIf { true }

  doFirst {
    jrubyScriptsDir.mkdirs()
    templateProperties.put('classpath', configurations.jruby.collect { it.toString() })

    def inputTemplate = file("script-templates/jruby${ext}")
    def engine = new SimpleTemplateEngine()
    Template template = engine.createTemplate(inputTemplate)
    outputScriptFile.write(template.make(templateProperties).toString())
    outputScriptFile.setExecutable(true)
  }
}

def initializeRailsGems = tasks.register('initializeRailsGems', JRuby) {
  group = LifecycleBasePlugin.BUILD_GROUP
  dependsOn createJRubyBinstubs

  def root = project.railsRoot
  outputs.dir(bundlePath)
  outputs.cacheIf { true }

  inputs.file("${root}/Gemfile")
  inputs.file("${root}/Gemfile.lock")
  inputs.file("${root}/.bundle/config")
  def jrubyScriptFile = createJRubyBinstubs.map { it.outputs.files.singleFile }
  inputs.file(jrubyScriptFile)
  inputs.property('railsRoot', root)

  workingDir = root
  args = ['-S', 'bundle', 'install']
  maxHeapSize = '384m'
  environment += [
    // RUBY env var needs to be forward-slashed on Windows to avoid backslashes getting stripped somewhere
    RUBY: jrubyScriptFile.get().toString().replaceAll('\\\\', '/'),
    // Avoid issues with jar-dependencies when running via jruby-as-jar https://github.com/jruby/jruby/issues/8886
    JARS_SKIP: 'true',
  ]
}

tasks.register('findGemsToNotPack', JRuby) {
  dependsOn initializeRailsGems

  def gemfile = "${project.railsRoot}/Gemfile"
  inputs.file(gemfile)
  inputs.file("${gemfile}.lock")
  inputs.file("find-gems-to-package.rake")

  def outputFile = layout.getBuildDirectory().file('gems-to-not-package.json')
  outputs.file(outputFile)
  outputs.cacheIf { true }

  environment += [
    OUTPUT_FILE   : outputFile.get(),
    BUNDLE_GEMFILE: gemfile,
  ]
  args = ['-S', 'bundle', 'exec', 'rake', '--trace', '--rakefile', 'find-gems-to-package.rake']
}

tasks.register('generateRubygemsLicenseReport', JRuby) {
  dependsOn initializeRailsGems

  def gemfile = "${project.railsRoot}/Gemfile"
  inputs.file(gemfile)
  inputs.file("${gemfile}.lock")
  inputs.file("rubygems-license-report.rake")

  def outputFile = layout.getBuildDirectory().file('rubygems-license.json')
  outputs.file(outputFile)
  outputs.cacheIf { true }

  environment += [
    OUTPUT_FILE   : outputFile.get(),
    BUNDLE_GEMFILE: gemfile,
  ]
  args = ['-S', 'bundle', 'exec', 'rake', '--trace', '--rakefile', 'rubygems-license-report.rake']
}

def yarnInstall = tasks.register('yarnInstall', YarnInstallTask) {
  workingDir = project.railsRoot
}

prepare.dependsOn(initializeRailsGems, yarnInstall)

tasks.register('cleanRails', Delete) {
  delete layout.buildDirectory.dir("railsTests")
  delete "${project.railsRoot}/config/cipher"
  delete "${project.railsRoot}/config/cipher.aes"
  delete "${project.railsRoot}/db/config.git"
  delete "${project.railsRoot}/db/h2db"
  delete "${project.railsRoot}/logs"
  delete "${project.railsRoot}/node_modules"
  delete "${project.railsRoot}/public/assets"
  delete "${project.railsRoot}/tmp"
  delete "${project.railsRoot}/webpack/gen"
  delete "${project.railsRoot}/yarn-error.log"
  delete "${project.railsRoot}/yarn-license-report"

  // these are purposely added as `doFirst` to avoid intellij from excluding these from the modules
  def injected = project.objects.newInstance(Injected)
  doFirst {
    injected.fileOps.delete {
      delete jrubyScriptsDir
      delete bundlePath
    }
  }
}
clean.dependsOn cleanRails

def generateJSRoutes = tasks.register('generateJSRoutes', ExecuteUnderRailsTask) {
  group = LifecycleBasePlugin.BUILD_GROUP

  dependsOn configurations.railsRuntimeClasspath
  classpath(configurations.railsRuntimeClasspath)

  inputs.dir("${project.railsRoot}/lib/tasks")
  inputs.dir("${project.railsRoot}/vendor")
  inputs.files(fileTree(dir: "${project.railsRoot}/config", includes: ['**/*.rb']))

  def outputDir = file("${project.railsRoot}/webpack/gen")
  outputs.dir(outputDir)
  outputs.cacheIf { true }

  environment(
    RAILS_ENV:    'production',
    RAILS_GROUPS: 'assets',
    OUTPUT_DIR:   outputDir,
  )

  args = ['-S', 'rake', '--trace', 'generated_js']

  doFirst {
    delete outputDir
  }
}

tasks.register('compileAssetsWebpackDev', YarnRunTask) {
  dependsOn yarnInstall, generateJSRoutes

  def yarnLicenseReportFile = layout.buildDirectory.file("reports/yarn-license/license-report.json").get().asFile
  outputs.dir(yarnLicenseReportFile.parentFile)

  source(fileTree(project.railsRoot) { include "eslint*.config.mjs" })
  source("${project.railsRoot}/babel.config.json")
  source("${project.railsRoot}/tsconfig.json")
  source("${project.railsRoot}/.stylelintrc.yml")

  source("${project.railsRoot}/webpack")
  source("${project.railsRoot}/vendor/assets")
  source("${project.railsRoot}/config")

  workingDir = project.railsRoot
  destinationDir = project.file("${project.railsRoot}/public/assets/webpack")
  yarnCommand = ['webpack-dev', '--env', "outputDir=${destinationDir.toPath().toString()}", '--env', "licenseReportFile=${yarnLicenseReportFile}"]

  doFirst {
    delete "${workingDir}/tmp" // Clean the cacheDir from webpack/config/webpack.config.ts
  }
}

tasks.register('compileAssetsWebpackProd', YarnRunTask) {
  dependsOn yarnInstall, generateJSRoutes

  def yarnLicenseReportFile = layout.buildDirectory.file("reports/yarn-license-prod/license-report.json").get().asFile
  outputs.dir(yarnLicenseReportFile.parentFile)

  source(fileTree(project.railsRoot) { include "eslint*.config.mjs" })
  source("${project.railsRoot}/babel.config.json")
  source("${project.railsRoot}/tsconfig.json")
  source("${project.railsRoot}/.stylelintrc.yml")

  source("${project.railsRoot}/webpack")
  source("${project.railsRoot}/vendor/assets")
  source("${project.railsRoot}/config")

  workingDir = project.railsRoot
  destinationDir = layout.buildDirectory.dir("webpack-assets").get().asFile
  yarnCommand = ['webpack-prod', '--env', "outputDir=${destinationDir.toPath().toString()}", '--env', "licenseReportFile=${yarnLicenseReportFile}"]

  doFirst {
    delete "${workingDir}/tmp" // Clean the cacheDir from webpack/config/webpack.config.ts
  }
}

def compileAssetsRailsTest = tasks.register('compileAssetsRailsTest', ExecuteUnderRailsTask) {
  dependsOn yarnInstall, configurations.railsRuntimeClasspath
  classpath(configurations.railsRuntimeClasspath)

  inputs.dir("${project.railsRoot}/config")
  inputs.dir("${project.railsRoot}/app/assets")
  inputs.dir("${project.railsRoot}/vendor/assets")
  inputs.files(compileAssetsWebpackDev) // This is solely because webpack-dev generates assets under public/assets/webpack :(

  def railsPublicAssets = fileTree(dir: "${project.railsRoot}/public/assets", excludes: ['webpack'])
  outputs.files(railsPublicAssets)
  outputs.cacheIf { true }

  environment += [
    'RAILS_ENV'   : 'test',
    'RAILS_GROUPS': 'assets',
  ]

  maxHeapSize = '256m'
  // Don't clobber assets; use Gradle to do this so we can avoid clobbering webpack assets in same dir
  args = ['-S', 'rake', '--trace', 'assets:precompile']

  doFirst {
    delete "${workingDir}/tmp"
    delete railsPublicAssets
  }
}

tasks.register('compileAssetsRailsProd', ExecuteUnderRailsTask) {
  dependsOn yarnInstall, configurations.railsRuntimeClasspath
  classpath(configurations.railsRuntimeClasspath)

  inputs.dir("${project.railsRoot}/config")
  inputs.dir("${project.railsRoot}/app/assets")
  inputs.dir("${project.railsRoot}/vendor/assets")

  def outputAssetsDir = layout.buildDirectory.dir("rails-assets")
  def publicAssetsDir = layout.buildDirectory.dir("public/assets")
  outputs.dir(outputAssetsDir)
  outputs.dir(publicAssetsDir)
  outputs.cacheIf { true }

  environment(
    'RAILS_ENV': 'production',
    'RAILS_GROUPS': 'assets',
  )

  maxHeapSize = '256m'
  args = ['-S', 'rake', '--trace', 'assets:clobber', 'assets:precompile']

  def injected = project.objects.newInstance(Injected)
  doFirst {
    injected.fileOps.delete {
      delete "${workingDir}/tmp"
      delete outputAssetsDir
    }
    outputAssetsDir.get().asFile.parentFile.mkdirs()
  }

  doLast {
    injected.fileOps.copy {
      from publicAssetsDir
      into outputAssetsDir
    }
    injected.fileOps.delete {
      delete publicAssetsDir
    }
  }
}

tasks.register('compileAssets') {
  dependsOn compileAssetsWebpackProd
  dependsOn licenseReportAggregate
  dependsOn compileAssetsRailsProd
  inputs.files licenseReportAggregate
  inputs.files compileAssetsRailsProd
  inputs.files compileAssetsWebpackProd

  def outputDir = layout.buildDirectory.dir("assets").get().asFile
  outputs.dir(outputDir)

  def injected = project.objects.newInstance(Injected)
  doFirst {
    delete outputDir

    injected.fileOps.copy {
      from licenseReportAggregate
      // assets are cached with a long lived cache header
      // we purposefully add a version string in the path so every new build will basically use a different url
      into "${outputDir}/dependency-license-report-${version}"
    }
    injected.fileOps.copy {
      from compileAssetsRailsProd
      into outputDir
    }
    injected.fileOps.copy {
      from compileAssetsWebpackProd
      into "${outputDir}/webpack"
    }
  }
}

tasks.register('rspec', ExecuteUnderRailsTask) {
  dependsOn ':server:cleanDb', initializeRailsGems, compileAssetsRailsTest, configurations.railsTestRuntimeClasspath
  classpath(configurations.railsTestRuntimeClasspath, rootProject.findProject(':test:test-utils').files("resource-include-in-all-projects"))

  description = "Run specs (pass '-Popts=...' to pass options)"

  inputs.dir(bundlePath)
  inputs.dir("${project.railsRoot}/app")
  inputs.dir("${project.railsRoot}/config")
  inputs.dir("${project.railsRoot}/lib")
  inputs.dir("${project.railsRoot}/spec")
  inputs.files(compileAssetsRailsTest)

  maxHeapSize = '256m'
  jvmArgs += (InstallerType.server.jvmInternalAccessArgs - jvmArgs) // Add additional args not already needed by JRuby alone
  args = ['-S', 'rspec', '--backtrace']
  if (project.hasProperty('opts')) {
    args += Commandline.translateCommandline(project.property('opts') as String)
  }
  environment += [
    'REPORTS_DIR': "${layout.buildDirectory.get()}/rspec-results"
  ]

  def testDataDir = layout.buildDirectory.dir('railsTests')
  def testConfigDir = testDataDir.map { it.dir('config') }
  systemProperties += [
    'cruise.config.dir'             : testConfigDir.get().asFile,
    'plugins.all.zip.path'          : testDataDir.map { it.file('plugins.zip') }.get().asFile,
    'rails.use.compressed.js'       : false,
    'go.enforce.server.immutability': 'N',
  ]

  def injected = project.objects.newInstance(Injected)
  doFirst {
    injected.fileOps.delete {  delete(testDataDir) }
    injected.fileOps.copy {
      from 'config'
      into testConfigDir
    }
  }
}

tasks.register('railsExec', ExecuteUnderRailsTask) {
  dependsOn yarnInstall, configurations.railsRuntimeClasspath
  classpath(configurations.railsRuntimeClasspath)
  outputs.upToDateWhen { false }

  description = "rails exec (pass '-Pcmd=...' to pass options)"

  args(Commandline.translateCommandline(project.properties.get('cmd') as String))
}
